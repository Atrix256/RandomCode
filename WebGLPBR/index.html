<html>
<head>
<title>WebGL</title>
<style type="text/css">
body { border-collapse: collapse; margin:0; padding:0;}
canvas#RenderWindow {position: absolute; left: 0; top: 0; z-index: 0; width:100%; height:100%;}
span#DebugPanel {position: absolute; right: 0; top: 0; z-index: 1; color: #00FF00; background-color: rgba(255,255,255,0.3); padding: 10px;}
span#FPSDisplay {position: absolute; left: 0; bottom: 0; z-index: 1; color: #00FF00; background-color: rgba(255,255,255,0.0); padding: 10px;}
span#LogDisplay {position: absolute; left: 0; top: 0; z-index: 1; color: #00FF00; background-color: rgba(255,255,255,0.3); padding: 10px;}
span#CameraPosDisplay {position: absolute; right: 0; bottom: 0; z-index: 1; color: #00FF00; background-color: rgba(255,255,255,0.0); padding: 10px;}
div#WholeWindow {position:relative; width:100%; height:100%;}
a#DebugPanelCollapseIcon {color:#00FF00;text-decoration: none; font-weight: bold; text-align: right; display: block;}
table {border-collapse: collapse; color: #00FF00;}
td, th {padding: 0;}
}
</style>
<script>
/*=========================================================================================
Created by Alan Wolfe
http://demofox.org
http://blog.demofox.org
https://twitter.com/Atrix256

=========================================================================================*/

var g_canvas = null;
var gl = null;
var g_debugPanelOpen = true;

var g_projectionMatrix;
var g_cameraMatrix;

var g_cameraPosition = [0,0,15];

var g_cameraYawPitchRoll = [0, 0, 0];

var g_cameraMoveSpeed = 2.0;    // meters per second
var g_cameraRotateSpeed = 0.01; // radians per second

var g_lastFrameTimeStamp = 0;
var g_frameCount = 0;
var g_frameCountTime = 0;

var g_keyState = new Array();

var g_pointerLocked = false;

var g_ambientLight = [0.001, 0.001, 0.001];

// a dictionary of file names to textures
var g_images = {};

g_imagesToLoad = [
  "white.png",

  "rustediron2_basecolor.png",
  "rustediron2_metallic.png",
  "rustediron2_roughness.png",
  "rustediron2_normal.png",

  "roughrockface2_Base_Color.png",
  "roughrockface2_Metallic.png",
  "roughrockface2_Roughness.png",
  "roughrockface2_Normal.png",
  "roughrockface2_Ambient_Occlusion.png",

  "greasy-pan-2-albedo.png",
  "greasy-pan-2-metal.png",
  "greasy-pan-2-normal.png",
  "greasy-pan-2-roughness.png",

  "Iron-Scuffed_basecolor.png",
  "Iron-Scuffed_metallic.png",
  "Iron-Scuffed_normal.png",
  "Iron-Scuffed_roughness.png",

  "sculptedfloorboards2b_AO.png",
  "sculptedfloorboards2b_basecolor.png",
  "sculptedfloorboards2b_metalness.png",
  "sculptedfloorboards2b_normal.png",
  "sculptedfloorboards2b_roughness.png",
];

var g_shaders = [];

var g_lastShaderUsed = null;

var g_light0Pos = [-5,-5, 5];
var g_light1Pos = [-5, 5, 5];
var g_light2Pos = [ 5,-5, 5];
var g_light3Pos = [ 5, 5, 5];

var g_light0ColorA = [300.0, 300.0, 300.0];
var g_light1ColorA = [300.0, 300.0, 300.0];
var g_light2ColorA = [300.0, 300.0, 300.0];
var g_light3ColorA = [300.0, 300.0, 300.0];

var g_light0ColorB = [300.0,   0.0,   0.0];
var g_light1ColorB = [  0.0, 300.0,   0.0];
var g_light2ColorB = [  0.0,   0.0, 300.0];
var g_light3ColorB = [300.0, 300.0,   0.0];

// You can use these uniforms in your vertex or pixel shaders without defining them, they are automatically defined and piped through if actually used.
var g_uniforms = {
  "u_projectionMatrix"      : ["mat4",      (key, location, objectValues) => {gl.uniformMatrix4fv(location, false, g_projectionMatrix);}],
  "u_cameraMatrix"          : ["mat4",      (key, location, objectValues) => {gl.uniformMatrix4fv(location, false, g_cameraMatrix);}],
  "u_screenResolution"      : ["vec2",      (key, location, objectValues) => {gl.uniform2fv(location, [gl.canvas.width, gl.canvas.height]);}],

  "u_cameraPosition"        : ["vec3",      (key, location, objectValues) => {gl.uniform3fv(location, g_cameraPosition);}],

  "u_ambientLight"          : ["vec3",      (key, location, objectValues) => {gl.uniform3fv(location, g_ambientLight);}],

  "u_light0Pos"             : ["vec3",      (key, location, objectValues) => {var pos = GetLightPos(0); gl.uniform3fv(location, pos);}],
  "u_light0Color"           : ["vec3",      (key, location, objectValues) => {var color = GetLightColor(0); gl.uniform3fv(location, color);}],

  "u_light1Pos"             : ["vec3",      (key, location, objectValues) => {var pos = GetLightPos(1); gl.uniform3fv(location, pos);}],
  "u_light1Color"           : ["vec3",      (key, location, objectValues) => {var color = GetLightColor(1); gl.uniform3fv(location, color);}],

  "u_light2Pos"             : ["vec3",      (key, location, objectValues) => {var pos = GetLightPos(2); gl.uniform3fv(location, pos);}],
  "u_light2Color"           : ["vec3",      (key, location, objectValues) => {var color = GetLightColor(2); gl.uniform3fv(location, color);}],

  "u_light3Pos"             : ["vec3",      (key, location, objectValues) => {var pos = GetLightPos(3); gl.uniform3fv(location, pos);}],
  "u_light3Color"           : ["vec3",      (key, location, objectValues) => {var color = GetLightColor(3); gl.uniform3fv(location, color);}],

  "u_objectMatrix"          : ["mat4",      (key, location, objectValues) => {gl.uniformMatrix4fv(location, false, GetObjectValue(objectValues, key));}],  
  "u_invTransObjectMatrix"  : ["mat4",      (key, location, objectValues) => {gl.uniformMatrix4fv(location, false, GetObjectValue(objectValues, key));}],  
  "u_objectAlbedo"          : ["vec3",      (key, location, objectValues) => {gl.uniform3fv(location, GetObjectValue(objectValues, key));}],
  "u_objectEmissive"        : ["vec3",      (key, location, objectValues) => {gl.uniform3fv(location, GetObjectValue(objectValues, key));}],
  "u_objectMetallic"        : ["float",     (key, location, objectValues) => {gl.uniform1f(location, GetObjectValue(objectValues, key));}],
  "u_objectRoughness"       : ["float",     (key, location, objectValues) => {gl.uniform1f(location, GetObjectValue(objectValues, key));}],
  "u_objectAO"              : ["float",     (key, location, objectValues) => {gl.uniform1f(location, GetObjectValue(objectValues, key));}],

  "u_textureAlbedo"         : ["sampler2D", (key, location, objectValues) => {gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, GetObjectValue(objectValues, key)); gl.uniform1i(location, 0);}],
  "u_textureMetallic"        : ["sampler2D", (key, location, objectValues) => {gl.activeTexture(gl.TEXTURE1); gl.bindTexture(gl.TEXTURE_2D, GetObjectValue(objectValues, key)); gl.uniform1i(location, 1);}],
  "u_textureRoughness"      : ["sampler2D", (key, location, objectValues) => {gl.activeTexture(gl.TEXTURE2); gl.bindTexture(gl.TEXTURE_2D, GetObjectValue(objectValues, key)); gl.uniform1i(location, 2);}],
  "u_textureNormal"         : ["sampler2D", (key, location, objectValues) => {gl.activeTexture(gl.TEXTURE3); gl.bindTexture(gl.TEXTURE_2D, GetObjectValue(objectValues, key)); gl.uniform1i(location, 3);}],  
  "u_textureAO"             : ["sampler2D", (key, location, objectValues) => {gl.activeTexture(gl.TEXTURE4); gl.bindTexture(gl.TEXTURE_2D, GetObjectValue(objectValues, key)); gl.uniform1i(location, 4);}],  
};

EOutputMode = {
    shaded : 0,
    albedo : 1,
    normal : 2,
    metallic : 3,
    roughness : 4,
    emissive : 5,    
    ao : 6,
    COUNT : 7,
};

var g_uniformsShaderSource = "";

//=========================================================================================
var precisionSource = "precision mediump float;\n\n";

//=========================================================================================
var vertexShaderSource = ` 
// vertex input
in vec4 a_position;
in vec3 a_normal;
in vec3 a_tangent;
in vec2 a_uv;
in vec3 a_barycentric;

// vertex output
out vec3 v_worldPos;
out vec3 v_normal;
out vec3 v_tangent;
out vec2 v_uv;
out vec3 v_barycentric;
out mat3 v_tbn;

void main()
{
  v_worldPos = (u_objectMatrix * a_position).xyz;

  // This offloads inverse transpose matrix calculation to the GPU, but is done per vertex instead of per object.
  //v_normal = mat3(transpose(inverse(u_objectMatrix))) * a_normal;  

  // write out the world space normal and tangent vectors
  v_normal = mat3(u_invTransObjectMatrix) * a_normal;
  v_tangent = mat3(u_invTransObjectMatrix) * a_tangent;  

  // make TBN matrix via Gram-Schmidt process
  vec3 T = normalize(vec3(u_objectMatrix * vec4(a_tangent, 0.0)));
  vec3 N = normalize(vec3(u_objectMatrix * vec4(a_normal, 0.0)));
  T = normalize(T - dot(T, N) * N);
  vec3 B = cross(N, T);
  v_tbn = mat3(T, B, N);  

  v_uv = a_uv;
  v_barycentric = a_barycentric;
  gl_Position = u_projectionMatrix * u_cameraMatrix * u_objectMatrix * a_position;
}
`;
 
 //=========================================================================================
var fragmentShaderSource = ` 

// pixel input
in vec3 v_worldPos;
in vec3 v_normal;
in vec3 v_tangent;
in vec2 v_uv;
in vec3 v_barycentric;
in mat3 v_tbn;

// pixel output
out vec4 outColor;

// TODO: clean up all this code

const float PI = 3.14159265359;

float DistributionGGX(vec3 N, vec3 H, float roughness)
{
    float a      = roughness*roughness;
    float a2     = a*a;
    float NdotH  = max(dot(N, H), 0.0);
    float NdotH2 = NdotH*NdotH;
  
    float nom   = a2;
    float denom = (NdotH2 * (a2 - 1.0) + 1.0);
    denom = PI * denom * denom;
  
    return nom / denom;
}

float GeometrySchlickGGX(float NdotV, float roughness)
{
    float r = (roughness + 1.0);
    float k = (r*r) / 8.0;

    float nom   = NdotV;
    float denom = NdotV * (1.0 - k) + k;
  
    return nom / denom;
}
float GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)
{
    float NdotV = max(dot(N, V), 0.0);
    float NdotL = max(dot(N, L), 0.0);
    float ggx2  = GeometrySchlickGGX(NdotV, roughness);
    float ggx1  = GeometrySchlickGGX(NdotL, roughness);
  
    return ggx1 * ggx2;
}

vec3 fresnelSchlick(float cosTheta, vec3 F0)
{
    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
}  

vec3 PositionalLight (vec3 worldPos, vec3 N, vec3 V, vec3 lightPos, vec3 lightColor, vec3 albedo, float metallic, float roughness)
{
  float distance    = length(lightPos - worldPos);
  float attenuation = 1.0 / (distance * distance);
  vec3 L = normalize(lightPos - worldPos);  

  vec3 H = normalize(V + L);  

  vec3 radiance     = lightColor * attenuation;     

  vec3 F0 = vec3(0.04); 
  F0      = mix(F0, albedo, metallic);
  vec3 F  = fresnelSchlick(max(dot(H, V), 0.0), F0);    

  float NDF = DistributionGGX(N, H, roughness);       
  float G   = GeometrySmith(N, V, L, roughness);     

  vec3 nominator    = NDF * G * F;
  float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0) + 0.001; 
  vec3 specular     = nominator / denominator;       

  vec3 kS = F;
  vec3 kD = vec3(1.0) - kS;
    
  kD *= 1.0 - metallic;     

  float NdotL = max(dot(N, L), 0.0);        
  return (kD * albedo / PI + specular) * radiance * NdotL;  
}
 
void main()
{
  #if DEBUG_WIREFRAME
    float margin = length(fwidth(v_barycentric)) * 0.25;

    float barycentricMin = min(v_barycentric.x, min(v_barycentric.y, v_barycentric.z));
    if (barycentricMin > margin) //0.025)
      discard;
  #endif

  vec3 N = normalize(v_normal); 
  vec3 V = normalize(u_cameraPosition - v_worldPos);  

  vec3 col = u_objectEmissive;

  vec3 objectAlbedo = u_objectAlbedo;
  float objectMetallic = u_objectMetallic;
  float objectRoughness = u_objectRoughness;
  float objectAO = u_objectAO;

  #if USE_TEXTURES
    vec3 texAlbedo = pow(texture(u_textureAlbedo, v_uv).rgb, vec3(2.2));
    float texMetallic = texture(u_textureMetallic, v_uv).r;
    float texRoughness = texture(u_textureRoughness, v_uv).r;
    float texAO = texture(u_textureAO, v_uv).r;

    N = texture(u_textureNormal, v_uv).rgb;
    N = normalize(N * 2.0 - 1.0);
    N = normalize(v_tbn * N);
  #else
    vec3 texAlbedo = vec3(1.0);
    float texMetallic = 0.5;
    float texRoughness = 0.5;
    float texAO = 1.0;
  #endif

  objectAlbedo *= texAlbedo;
  objectAO *= texAO;

  // TODO: do these branchlessly
  if (objectMetallic <= 1.0)
    objectMetallic = mix(0.0, texMetallic, objectMetallic);
  else
    objectMetallic = mix(texMetallic, 1.0, objectMetallic - 1.0);

  if (objectRoughness <= 1.0)
    objectRoughness = mix(0.0, texRoughness, objectRoughness);
  else
    objectRoughness = mix(texRoughness, 1.0, objectRoughness - 1.0);

  col += PositionalLight(v_worldPos, N, V, u_light0Pos, u_light0Color, objectAlbedo, objectMetallic, objectRoughness) * objectAO;
  col += PositionalLight(v_worldPos, N, V, u_light1Pos, u_light1Color, objectAlbedo, objectMetallic, objectRoughness) * objectAO;
  col += PositionalLight(v_worldPos, N, V, u_light2Pos, u_light2Color, objectAlbedo, objectMetallic, objectRoughness) * objectAO;
  col += PositionalLight(v_worldPos, N, V, u_light3Pos, u_light3Color, objectAlbedo, objectMetallic, objectRoughness) * objectAO;

  col += u_ambientLight * objectAlbedo * objectAO;

  // HDR -> LDR
  col = col / (col + vec3(1.0));

  #if OUTPUT_MODE == OUTPUT_MODE_SHADED
    outColor.rgb = pow(col, vec3(1.0/2.2));
  #endif

  #if OUTPUT_MODE == OUTPUT_MODE_ALBEDO
    outColor.rgb = objectAlbedo;
  #endif

  #if OUTPUT_MODE == OUTPUT_MODE_NORMAL
    outColor.rgb = N * 0.5 + 0.5;
  #endif  

  #if OUTPUT_MODE == OUTPUT_MODE_METALLIC
    outColor.rgb = vec3(objectMetallic);
  #endif    

  #if OUTPUT_MODE == OUTPUT_MODE_ROUGHNESS
    outColor.rgb = vec3(objectRoughness);
  #endif     

  #if OUTPUT_MODE == OUTPUT_MODE_EMISSIVE
    outColor.rgb = u_objectEmissive;
  #endif 

  #if OUTPUT_MODE == OUTPUT_MODE_AO
    outColor.rgb = vec3(objectAO);
  #endif     

  outColor.a = 1.0;   
}
`;

//=========================================================================================
function GetLightColor (lightIndex)
{
  if (document.getElementById("Debug_UseColoredLights").checked)
  {
    switch(lightIndex)
    {
      case 0: return g_light0ColorB;
      case 1: return g_light1ColorB;
      case 2: return g_light2ColorB;
      case 3: return g_light3ColorB;                  
    }
  }
  else
  {
    switch(lightIndex)
    {
      case 0: return g_light0ColorA;
      case 1: return g_light1ColorA;
      case 2: return g_light2ColorA;
      case 3: return g_light3ColorA;                  
    }
  }
}

//=========================================================================================
function GetLightPos (lightIndex)
{

  if (!document.getElementById("Debug_PointLight" + lightIndex).checked)
  {
    return [-10000, -10000, -10000];
  }

  if (document.getElementById("Debug_AnimateLights").checked)
  {
    var seconds = new Date().getTime() / 1000;
    var offset = [];
    offset[0] = Math.sin(seconds * (lightIndex + 1)) * 2;
    offset[1] = Math.cos(seconds * (lightIndex + 1)) * 2;
    offset[2] = Math.sin(seconds * (lightIndex + 1)) * Math.cos(seconds * (lightIndex + 1)) * 3;

    switch(lightIndex)
    {
      case 0: return [g_light0Pos[0] + offset[0], g_light0Pos[1] + offset[1], g_light0Pos[2] + offset[2]];
      case 1: return [g_light1Pos[0] + offset[0], g_light1Pos[1] + offset[1], g_light1Pos[2] + offset[2]];
      case 2: return [g_light2Pos[0] + offset[0], g_light2Pos[1] + offset[1], g_light2Pos[2] + offset[2]];
      case 3: return [g_light3Pos[0] + offset[0], g_light3Pos[1] + offset[1], g_light3Pos[2] + offset[2]];            
    }
  }
  else
  {
    switch(lightIndex)
    {
      case 0: return g_light0Pos;
      case 1: return g_light1Pos;
      case 2: return g_light2Pos;
      case 3: return g_light3Pos;                  
    }
  }
}

//=========================================================================================
function GetNumShaderPermutations ()
{
  return EOutputMode.COUNT * 4;
}

//=========================================================================================
function GetShaderPermutationIndex (wireFrame, useTextures, outputMode)
{
  var ret = 0;
  if (wireFrame)
    ret += 1;
  if (useTextures)
    ret += 2;
  ret += outputMode * 4;
  return ret;
}

//=========================================================================================
function GetShaderPermutationSourceString (index)
{
  return "#define DEBUG_WIREFRAME " + (index % 2) + "\n" +
         "#define USE_TEXTURES " + (Math.floor(index/2) % 2) + "\n" + 
         "#define OUTPUT_MODE " + Math.floor(index/4) + "\n" +
         "#define OUTPUT_MODE_SHADED    0\n" +
         "#define OUTPUT_MODE_ALBEDO    1\n" +
         "#define OUTPUT_MODE_NORMAL    2\n" +
         "#define OUTPUT_MODE_METALLIC  3\n" +
         "#define OUTPUT_MODE_ROUGHNESS 4\n" +
         "#define OUTPUT_MODE_EMISSIVE  5\n" +
         "#define OUTPUT_MODE_AO        6\n" +
         "\n";
}

//=========================================================================================
function CreateShader (gl, type, source, permutationSource) {
  var fullSource = "#version 300 es\n\n" + precisionSource + permutationSource + g_uniformsShaderSource + source;

  var shader = gl.createShader(type);
  gl.shaderSource(shader, fullSource);
  gl.compileShader(shader);
  var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
  if (success) {
    return shader;
  }

  var shaderErrorInfo = gl.getShaderInfoLog(shader);
  alert(shaderErrorInfo + "\n" + fullSource);

  console.log(shaderErrorInfo);
  console.log(fullSource);
  gl.deleteShader(shader);
}

//=========================================================================================
function CreateProgram (gl, vertexShader, fragmentShader) {
  var program = gl.createProgram();
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.linkProgram(program);
  var success = gl.getProgramParameter(program, gl.LINK_STATUS);
  if (success) {
    return program;
  }
 
  console.log(gl.getProgramInfoLog(program));
  gl.deleteProgram(program);
}

//=========================================================================================
function MakeShader (vertexSource, fragmentSource, permutationSource)
{
    // compile shader
    var vertexShader = CreateShader(gl, gl.VERTEX_SHADER, vertexSource, permutationSource);
    var fragmentShader = CreateShader(gl, gl.FRAGMENT_SHADER, fragmentSource, permutationSource);    
    var program = CreateProgram(gl, vertexShader, fragmentShader);

    // get the uniform locations, for any uniforms it may use
    var shader = {};
    shader.program = program;
    shader.uniforms = {};
    for (var key in g_uniforms)
      shader.uniforms[key] = gl.getUniformLocation(shader.program, key);

    // return the shader to the caller
    return shader;
}

//=========================================================================================
function UpdateCameraMatrix ()
{
    g_cameraMatrix = CameraMatrix(g_cameraYawPitchRoll, VectorMultiply(g_cameraPosition, -1));
}

//=========================================================================================
function UpdateProjectionMatrix ()
{
    g_projectionMatrix = Perspective(45.0 * 3.14 / 180.0, gl.canvas.width / gl.canvas.height, 1.0, 2000.0);
}

//=========================================================================================
function Resize (canvas) {
  // Lookup the size the browser is displaying the canvas.
  var displayWidth  = canvas.clientWidth;
  var displayHeight = canvas.clientHeight;
 
  // Check if the canvas is not the same size.
  if (canvas.width  !== displayWidth ||
      canvas.height !== displayHeight) {
 
      // Make the canvas the same size
      canvas.width  = displayWidth;
      canvas.height = displayHeight;

      UpdateProjectionMatrix();
  }
}

//=========================================================================================
function Perspective (fieldOfViewInRadians, aspect, near, far) {
    var f = Math.tan(Math.PI * 0.5 - 0.5 * fieldOfViewInRadians);
    var rangeInv = 1.0 / (near - far);
 
    return [
      f / aspect, 0, 0, 0,
      0, f, 0, 0,
      0, 0, (near + far) * rangeInv, -1,
      0, 0, near * far * rangeInv * 2, 0
    ];
}

//=========================================================================================
function MultiplyMatrix4x4 (A, B)
{
  var ret = [];

  for (var i = 0; i < 4; ++i)
  {
    for (var j = 0; j < 4; ++j)
    {
      ret[i*4+j] = 
        A[i*4+0] * B[0*4+j] + 
        A[i*4+1] * B[1*4+j] + 
        A[i*4+2] * B[2*4+j] + 
        A[i*4+3] * B[3*4+j];
    }
  }

  return ret;
}

//=========================================================================================
function CameraMatrix (yawPitchRoll, translation) {

  var cosAlpha = Math.cos(yawPitchRoll[2]);
  var sinAlpha = Math.sin(yawPitchRoll[2]);

  var cosBeta = Math.cos(yawPitchRoll[0]);
  var sinBeta = Math.sin(yawPitchRoll[0]);

  var cosGamma = Math.cos(yawPitchRoll[1]);
  var sinGamma = Math.sin(yawPitchRoll[1]);

  var rot = [
    cosAlpha * cosBeta, cosAlpha * sinBeta * sinGamma - sinAlpha * cosGamma, cosAlpha * sinBeta * cosGamma + sinAlpha * sinGamma, 0,
    sinAlpha * cosBeta, sinAlpha * sinBeta * sinGamma + cosAlpha * cosGamma, sinAlpha * sinBeta * cosGamma - cosAlpha * sinGamma, 0,
    -sinBeta, cosBeta * sinGamma, cosBeta * cosGamma, 0,
    0, 0, 0, 1
  ];

  var trans = [
    1, 0, 0, 0,
    0, 1, 0, 0,
    0, 0, 1, 0,
    translation[0], translation[1], translation[2], 1
  ];

  return MultiplyMatrix4x4(trans, rot);
}

//=========================================================================================
function TransformationMatrix (yawPitchRoll, translation, scale) {

  var cosAlpha = Math.cos(yawPitchRoll[2]);
  var sinAlpha = Math.sin(yawPitchRoll[2]);

  var cosBeta = Math.cos(yawPitchRoll[0]);
  var sinBeta = Math.sin(yawPitchRoll[0]);

  var cosGamma = Math.cos(yawPitchRoll[1]);
  var sinGamma = Math.sin(yawPitchRoll[1]);

  var rot = [
    cosAlpha * cosBeta, cosAlpha * sinBeta * sinGamma - sinAlpha * cosGamma, cosAlpha * sinBeta * cosGamma + sinAlpha * sinGamma, 0,
    sinAlpha * cosBeta, sinAlpha * sinBeta * sinGamma + cosAlpha * cosGamma, sinAlpha * sinBeta * cosGamma - cosAlpha * sinGamma, 0,
    -sinBeta, cosBeta * sinGamma, cosBeta * cosGamma, 0,
    0, 0, 0, 1
  ];

  var scale = [
    scale[0], 0, 0, 0,
    0, scale[1], 0, 0,
    0, 0, scale[2], 0,
    0, 0, 0, 1,
  ];

  var trans = [
    1, 0, 0, 0,
    0, 1, 0, 0,
    0, 0, 1, 0,
    translation[0], translation[1], translation[2], 1
  ];

  return MultiplyMatrix4x4(MultiplyMatrix4x4(scale, rot), trans);
}

//=========================================================================================
function MatrixTranspose4x4 (matrix)
{
  return [
    matrix[0*4+0], matrix[1*4+0], matrix[2*4+0], matrix[3*4+0],
    matrix[0*4+1], matrix[1*4+1], matrix[2*4+1], matrix[3*4+1],
    matrix[0*4+2], matrix[1*4+2], matrix[2*4+2], matrix[3*4+2],
    matrix[0*4+3], matrix[1*4+3], matrix[2*4+3], matrix[3*4+3],
  ];
}

//=========================================================================================
function InverseTransposeTransformationMatrix (yawPitchRoll, translation, scale) {

  var cosAlpha = Math.cos(yawPitchRoll[2]);
  var sinAlpha = Math.sin(yawPitchRoll[2]);

  var cosBeta = Math.cos(yawPitchRoll[0]);
  var sinBeta = Math.sin(yawPitchRoll[0]);

  var cosGamma = Math.cos(yawPitchRoll[1]);
  var sinGamma = Math.sin(yawPitchRoll[1]);

  var rot = [
    cosAlpha * cosBeta, cosAlpha * sinBeta * sinGamma - sinAlpha * cosGamma, cosAlpha * sinBeta * cosGamma + sinAlpha * sinGamma, 0,
    sinAlpha * cosBeta, sinAlpha * sinBeta * sinGamma + cosAlpha * cosGamma, sinAlpha * sinBeta * cosGamma - cosAlpha * sinGamma, 0,
    -sinBeta, cosBeta * sinGamma, cosBeta * cosGamma, 0,
    0, 0, 0, 1
  ];
  // inverse of a rotatiuon matrix is it's transpose
  rot = MatrixTranspose4x4(rot);

  var scale = [
    1/scale[0], 0, 0, 0,
    0, 1/scale[1], 0, 0,
    0, 0, 1/scale[2], 0,
    0, 0, 0, 1,
  ];

  var trans = [
    1, 0, 0, 0,
    0, 1, 0, 0,
    0, 0, 1, 0,
    -translation[0], -translation[1], -translation[2], 1
  ];

  var inverse = MultiplyMatrix4x4(trans, MultiplyMatrix4x4(rot, scale));
  return MatrixTranspose4x4(inverse);
}

//=========================================================================================
function MatrixToString (matrix)
{
  var ret = "";

  ret += matrix[0*4+0].toFixed(2) + ", " + matrix[0*4+1].toFixed(2) + ", " + matrix[0*4+2].toFixed(2) + ", " + matrix[0*4+3].toFixed(2) + "\n";
  ret += matrix[1*4+0].toFixed(2) + ", " + matrix[1*4+1].toFixed(2) + ", " + matrix[1*4+2].toFixed(2) + ", " + matrix[1*4+3].toFixed(2) + "\n";
  ret += matrix[2*4+0].toFixed(2) + ", " + matrix[2*4+1].toFixed(2) + ", " + matrix[2*4+2].toFixed(2) + ", " + matrix[2*4+3].toFixed(2) + "\n";
  ret += matrix[3*4+0].toFixed(2) + ", " + matrix[3*4+1].toFixed(2) + ", " + matrix[3*4+2].toFixed(2) + ", " + matrix[3*4+3].toFixed(2) + "\n";

  return ret;
}

// TODO: make general for any sized vector and rename to VectorNormalize
//=========================================================================================
function NormalizeVector (v)
{
  var length = Math.sqrt(v[0]*v[0]+v[1]*v[1]+v[2]*v[2]);
  return [v[0]/length, v[1]/length, v[2]/length];
}

//=========================================================================================
function VectorSubtract(a, b)
{
	var ret = [];
	for (var i = 0; i < a.length; ++i)
		ret[i] = a[i] - b[i];
	return ret;
}

//=========================================================================================
function VectorDivide(a, b)
{
	var ret = [];
	for (var i = 0; i < a.length; ++i)
		ret[i] = a[i] / b;
	return ret;
}

//=========================================================================================
function VectorMultiply(a, b)
{
	var ret = [];
	for (var i = 0; i < a.length; ++i)
		ret[i] = a[i] * b;
	return ret;
}

//=========================================================================================
function VectorCrossProduct(a, b)
{
  return [
    a[1] * b[2] - a[2] * b[1],
    a[2] * b[0] - a[0] * b[2],
    a[0] * b[1] - a[1] * b[0]
  ];
}

//=========================================================================================
function CameraForward ()
{
  return [g_cameraMatrix[0*4+2], g_cameraMatrix[1*4+2], g_cameraMatrix[2*4+2]];
}

//=========================================================================================
function CameraRight ()
{
  return [g_cameraMatrix[0*4+0], g_cameraMatrix[1*4+0], g_cameraMatrix[2*4+0]];
}

//=========================================================================================
function GetObjectValue (objectValues, key)
{
  if (objectValues[key] == null)
    throw new Error("Missing object value asked for in GetObjectValue() : " + key);

  return objectValues[key];
}

//=========================================================================================
function FillUniformValue (key, location, objectValues)
{
  // if the shader doesn't use this uniform, nothing to fill in
  if (location == null)
    return;

  // else fill it in with the lambda
  g_uniforms[key][1](key, location, objectValues);
}

//=========================================================================================
function PrepareToDrawMesh (translation, yawPitchRoll, scale, albedo, emissive, metallic, roughness, textures)
{
  // get the right shader to use
  var shader = g_shaders[GetShaderPermutationIndex(
    document.getElementById("Debug_Wireframe").checked,
    textures != null,
    document.getElementById("Debug_OutputMode").selectedIndex
  )];

  if (document.getElementById("Debug_Wireframe").checked)
    gl.disable(gl.CULL_FACE);
  else
    gl.enable(gl.CULL_FACE);
  gl.frontFace(gl.CW);

  // Tell it to use our program (pair of shaders)
  if (g_lastShaderUsed != shader.program)
  {
    gl.useProgram(shader.program);    
    g_lastShaderUsed = shader.program;
  }

  // make our object values
  var objectValues = {};
  objectValues.u_objectMatrix = TransformationMatrix(yawPitchRoll, translation, scale);
  objectValues.u_invTransObjectMatrix = InverseTransposeTransformationMatrix(yawPitchRoll, translation, scale);
  objectValues.u_objectAlbedo = albedo;
  objectValues.u_objectEmissive = emissive;    
  objectValues.u_objectMetallic = metallic;
  objectValues.u_objectRoughness = roughness;
  objectValues.u_objectAO = 1.0;
  if (textures != null)
  {
    objectValues.u_textureAlbedo = textures[0];
    objectValues.u_textureMetallic = textures[1];
    objectValues.u_textureRoughness = textures[2];
    objectValues.u_textureNormal = textures[3];
    objectValues.u_textureAO = textures[4];
  }

  // fill out the uniforms
  for (var key in shader.uniforms)
      FillUniformValue(key, shader.uniforms[key], objectValues);

  return shader;
}

//=========================================================================================
function DrawTetrahedron (translation, yawPitchRoll, scale, albedo, emissive, metallic, roughness, textures)
{
  var shader = PrepareToDrawMesh(translation, yawPitchRoll, scale, albedo, emissive, metallic, roughness, textures);

  // Bind the attribute/buffer set we want.
  gl.bindVertexArray(shader.tetrahedronMesh);    

  var primitiveType = gl.TRIANGLES;
  var offset = 0;
  var count = shader.tetrahedronMeshVertCount / 3;
  gl.drawArrays(primitiveType, offset, count);    
}

//=========================================================================================
function DrawCube (translation, yawPitchRoll, scale, albedo, emissive, metallic, roughness, textures)
{
  var shader = PrepareToDrawMesh(translation, yawPitchRoll, scale, albedo, emissive, metallic, roughness, textures);

  // Bind the attribute/buffer set we want.
  gl.bindVertexArray(shader.cubeMesh);    

  var primitiveType = gl.TRIANGLES;
  var offset = 0;
  var count = shader.cubeMeshVertCount / 3;
  gl.drawArrays(primitiveType, offset, count);    
}

//=========================================================================================
function DrawSphere (translation, yawPitchRoll, scale, albedo, emissive, metallic, roughness, textures)
{
  var shader = PrepareToDrawMesh(translation, yawPitchRoll, scale, albedo, emissive, metallic, roughness, textures);

  // Bind the attribute/buffer set we want.
  gl.bindVertexArray(shader.sphereMesh);    

  var primitiveType = gl.TRIANGLES;
  var offset = 0;
  var count = shader.sphereMeshVertCount / 3;
  gl.drawArrays(primitiveType, offset, count);      
}

//=========================================================================================
function HandleInput (deltaTime)
{
  if (!g_pointerLocked)
    return;

  // W or up arrowd
  var movement = g_cameraMoveSpeed * deltaTime;
  if (g_keyState[87] || g_keyState[38])
  {
    var vec = CameraForward();
    g_cameraPosition[0] -= vec[0] * movement;
    g_cameraPosition[1] -= vec[1] * movement;
    g_cameraPosition[2] -= vec[2] * movement;
    UpdateCameraMatrix();

    document.getElementById("CameraPosDisplay").innerText = "Camera: (" + g_cameraPosition[0].toFixed(2) + ", " + g_cameraPosition[1].toFixed(2) + ", " + g_cameraPosition[2].toFixed(2) + ")";
  }
  // S or down arrow
  if (g_keyState[83] || g_keyState[40])
  {
    var vec = CameraForward();
    g_cameraPosition[0] += vec[0] * movement;
    g_cameraPosition[1] += vec[1] * movement;
    g_cameraPosition[2] += vec[2] * movement;      
    UpdateCameraMatrix();

    document.getElementById("CameraPosDisplay").innerText = "Camera: (" + g_cameraPosition[0].toFixed(2) + ", " + g_cameraPosition[1].toFixed(2) + ", " + g_cameraPosition[2].toFixed(2) + ")";
  }
  // A or left arrow
  if (g_keyState[65] || g_keyState[37])
  {
    var vec = CameraRight();
    g_cameraPosition[0] -= vec[0] * movement;
    g_cameraPosition[1] -= vec[1] * movement;
    g_cameraPosition[2] -= vec[2] * movement;          
    UpdateCameraMatrix();

    document.getElementById("CameraPosDisplay").innerText = "Camera: (" + g_cameraPosition[0].toFixed(2) + ", " + g_cameraPosition[1].toFixed(2) + ", " + g_cameraPosition[2].toFixed(2) + ")";
  }    
  // D or right arrow
  if (g_keyState[68] || g_keyState[39])
  {
    var vec = CameraRight();
    g_cameraPosition[0] += vec[0] * movement;
    g_cameraPosition[1] += vec[1] * movement;
    g_cameraPosition[2] += vec[2] * movement;          
    UpdateCameraMatrix();

    document.getElementById("CameraPosDisplay").innerText = "Camera: (" + g_cameraPosition[0].toFixed(2) + ", " + g_cameraPosition[1].toFixed(2) + ", " + g_cameraPosition[2].toFixed(2) + ")";
  }         
}

//=========================================================================================
function DrawScene (thisFrameTimeStamp)
{
    // calculate a delta time for our frame
    var deltaTime = 0.0;
    if (typeof thisFrameTimeStamp != 'undefined')
    {
      thisFrameTimeStamp *= 0.001;
      deltaTime = thisFrameTimeStamp - g_lastFrameTimeStamp;
      g_lastFrameTimeStamp = thisFrameTimeStamp;
    }

    // handle FPS calculation
    g_frameCount++;
    g_frameCountTime+=deltaTime;
    if (g_frameCountTime > 0.5)
    {
      var fps = g_frameCount / g_frameCountTime;
      document.getElementById("FPSDisplay").innerText = "(" + gl.canvas.width + "x" + gl.canvas.height + ") FPS: " + fps.toFixed(2) + " (" + (1000/fps).toFixed(2)+ " ms)";
      g_frameCount = 0;
      g_frameCountTime = 0;
    }

    // user input
    HandleInput(deltaTime)

    // Draw
    Resize(gl.canvas);
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

    // enable depth test
    gl.enable(gl.DEPTH_TEST);
    gl.depthFunc(gl.LESS);

    // Clear the canvas
    gl.clearColor(0.1, 0.1, 0.1, 1);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);    

    // animate object by rotating it over time if we should
    var objectYawPitchRoll = [0,0,0];
    if (document.getElementById("Debug_AnimateObjects").checked)
    {
      var seconds = new Date().getTime() / 1000;
      objectYawPitchRoll[0] = seconds * 0.25 * 2;
      objectYawPitchRoll[1] = seconds * 0.3 * 2;
      objectYawPitchRoll[2] = seconds * 0.7 * 2;
    }    

    // get the material parameters
    var objectTextures = null;
    var objectAlebdo = [document.getElementById("Debug_AlbedoR").value, document.getElementById("Debug_AlbedoG").value, document.getElementById("Debug_AlbedoB").value];
    var objectMetallic = document.getElementById("Debug_Metallic").value;
    var objectRoughness = document.getElementById("Debug_Roughness").value;
    switch (document.getElementById("Debug_SceneMaterial").selectedIndex)
    {
      case 0:
      {
        break;
      }
      case 1:
      {
        objectTextures = [
          g_images["rustediron2_basecolor.png"],
          g_images["rustediron2_metallic.png"],
          g_images["rustediron2_roughness.png"],
          g_images["rustediron2_normal.png"],
          g_images["white.png"],
        ];
        break;
      }

      case 2:
      {
        objectTextures = [
          g_images["roughrockface2_Base_Color.png"],
          g_images["roughrockface2_Metallic.png"],
          g_images["roughrockface2_Roughness.png"],
          g_images["roughrockface2_Normal.png"],
          g_images["roughrockface2_Ambient_Occlusion.png"],
        ];
        break;
      }

      case 3:
      {
        objectTextures = [
          g_images["greasy-pan-2-albedo.png"],
          g_images["greasy-pan-2-metal.png"],
          g_images["greasy-pan-2-roughness.png"],
          g_images["greasy-pan-2-normal.png"],
          g_images["white.png"],
        ];
        break;
      }      

      case 4:
      {
        objectTextures = [
          g_images["Iron-Scuffed_basecolor.png"],
          g_images["Iron-Scuffed_metallic.png"],
          g_images["Iron-Scuffed_roughness.png"],
          g_images["Iron-Scuffed_normal.png"],
          g_images["white.png"],
        ];
        break;
      }     

      case 5:
      {
        objectTextures = [
          g_images["sculptedfloorboards2b_basecolor.png"],
          g_images["sculptedfloorboards2b_metalness.png"],
          g_images["sculptedfloorboards2b_roughness.png"],
          g_images["sculptedfloorboards2b_normal.png"],
          g_images["sculptedfloorboards2b_AO.png"],
        ];
        break;
      }          
    }

    // draw a grid of things if we are supposed to
    var objectType = document.getElementById("Debug_SceneObject").selectedIndex;
    if (document.getElementById("Debug_SceneSingle").selectedIndex == 0)
    {
      for (var iy = 0; iy < 9; ++iy)
      {
        for (var ix = 0; ix < 9; ++ix)
        {
          var rotMultiply = Math.sin((ix + 0.3) * (iy + 0.7)) % 1;

          if (objectType == 0)
          {
            DrawSphere(
              [(ix - 4), (iy - 4), 0],
              VectorMultiply(objectYawPitchRoll, rotMultiply),
              [0.4, 0.4, 0.4],
              objectAlebdo,
              [0, 0, 0],
              iy * 2 / 8,
              (ix / 8) * 1.95 + 0.05,
              objectTextures);
          }
          else if (objectType == 1)
          {
            DrawCube(
              [(ix - 4), (iy - 4), 0],
              VectorMultiply(objectYawPitchRoll, rotMultiply),
              [0.4, 0.4, 0.4],
              objectAlebdo,
              [0, 0, 0],
              iy * 2 / 8,
              (ix / 8) * 1.95 + 0.05,
              objectTextures);
          }
          else
          {
            DrawTetrahedron(
              [(ix - 4), (iy - 4), 0],
              VectorMultiply(objectYawPitchRoll, rotMultiply),
              [0.4, 0.4, 0.4],
              objectAlebdo,
              [0, 0, 0],
              iy / 8 * 2,
              (ix / 8) * 1.95 + 0.05,
              objectTextures);            
          }
        }
      }
    }
    else if (document.getElementById("Debug_SceneSingle").selectedIndex == 1)
    {
      for (var iy = 0; iy < 9; ++iy)
      {
        for (var ix = 0; ix < 9; ++ix)
        {
          var rotMultiply = Math.sin((ix + 0.3) * (iy + 0.7)) % 1;

          if (objectType == 0)
          {
            DrawSphere(
              [(ix - 4), (iy - 4), 0],
              VectorMultiply(objectYawPitchRoll, rotMultiply),
              [0.4, 0.4, 0.4],
              objectAlebdo,
              [0, 0, 0],
              objectMetallic, objectRoughness,
              objectTextures);
          }
          else if (objectType == 1)
          {
            DrawCube(
              [(ix - 4), (iy - 4), 0],
              VectorMultiply(objectYawPitchRoll, rotMultiply),
              [0.4, 0.4, 0.4],
              objectAlebdo,
              [0, 0, 0],
              objectMetallic, objectRoughness,
              objectTextures);
          }
          else
          {
            DrawTetrahedron(
              [(ix - 4), (iy - 4), 0],
              VectorMultiply(objectYawPitchRoll, rotMultiply),
              [0.4, 0.4, 0.4],
              objectAlebdo,
              [0, 0, 0],
              objectMetallic, objectRoughness,
              objectTextures);            
          }
        }
      }
    }    
    else if (document.getElementById("Debug_SceneSingle").selectedIndex == 2)
    {
      for (var iz = 0; iz < 9; ++iz)
      {
        for (var iy = 0; iy < 9; ++iy)
        {
          for (var ix = 0; ix < 9; ++ix)
          {
            var rotMultiply = Math.sin((ix + 0.3) * (iy + 0.7) * (iz + 0.5)) % 1;

            if (objectType == 0)
            {
              DrawSphere(
                [(ix - 4), (iy - 4), (iz - 8)],
                VectorMultiply(objectYawPitchRoll, rotMultiply),
                [0.4, 0.4, 0.4],
                objectAlebdo,
                [0, 0, 0],
                objectMetallic, objectRoughness,
                objectTextures);
            }
            else if (objectType == 1)
            {
              DrawCube(
                [(ix - 4), (iy - 4), (iz - 8)],
                VectorMultiply(objectYawPitchRoll, rotMultiply),
                [0.4, 0.4, 0.4],
                objectAlebdo,
                [0, 0, 0],
                objectMetallic, objectRoughness,
                objectTextures);
            }
            else
            {
              DrawTetrahedron(
                [(ix - 4), (iy - 4), (iz - 8)],
                VectorMultiply(objectYawPitchRoll, rotMultiply),
                [0.4, 0.4, 0.4],
                objectAlebdo,
                [0, 0, 0],
                objectMetallic, objectRoughness,
                objectTextures);            
            }
          }
        }
      }
    }        
    // else draw a single one
    else
    {
      if (objectType == 0)
      {      
        DrawSphere(
          [0, 0, 0],
          objectYawPitchRoll,
          [1, 1, 1],
          objectAlebdo,
          [0, 0, 0],
          objectMetallic, objectRoughness,
          objectTextures);
      }
      else if (objectType == 1)
      {
        DrawCube(
          [0, 0, 0],
          objectYawPitchRoll,
          [1, 1, 1],
          objectAlebdo,
          [0, 0, 0],
          objectMetallic, objectRoughness,
          objectTextures);
      }
      else
      {
        DrawTetrahedron(
          [0, 0, 0],
          objectYawPitchRoll,
          [1, 1, 1],
          objectAlebdo,
          [0, 0, 0],
          objectMetallic, objectRoughness,
          objectTextures);        
      }
    }

    // draw the light sources if we should
    if (document.getElementById("Debug_DrawPointLights").checked)
    {
      var color = GetLightColor(0);
      DrawSphere(
        GetLightPos(0), 
        [0,0,0],
        [0.1, 0.1, 0.1],
        [0, 0, 0],
        color,
        0,0,
        null
      );
      color = GetLightColor(1);
      DrawSphere(
        GetLightPos(1), 
        [0,0,0],
        [0.1, 0.1, 0.1],
        [0, 0, 0],
        color,
        0,0,
        null
      );
      color = GetLightColor(2);
      DrawSphere(
        GetLightPos(2), 
        [0,0,0],
        [0.1, 0.1, 0.1],
        [0, 0, 0],
        color,
        0,0,
        null
      );
      color = GetLightColor(3);
      DrawSphere(
        GetLightPos(3),
        [0,0,0],
        [0.1, 0.1, 0.1],
        [0, 0, 0],
        color,
        0,0,
        null
      );  
    }

    // request another frame to be drawn
    requestAnimationFrame(DrawScene);
}

//=========================================================================================
function ToggleDebugPanel ()
{
    g_debugPanelOpen = !g_debugPanelOpen;

    if (g_debugPanelOpen)
    {
        document.getElementById("DebugPanelControls").style.visibility = "visible";
        document.getElementById("DebugPanelControls").style.display = "";        
        document.getElementById("DebugPanelCollapseIcon").innerText="[-] Debug Panel";
    }
    else
    {
        document.getElementById("DebugPanelControls").style.visibility = "hidden";
        document.getElementById("DebugPanelControls").style.display = "none";        
        document.getElementById("DebugPanelCollapseIcon").innerText="[+] Debug Panel";
    }
}

//=========================================================================================
function OnKeyDown(event)
{
  g_keyState[event.keyCode] = true;
}

//=========================================================================================
function OnKeyUp(event)
{
  g_keyState[event.keyCode] = false;
}

//=========================================================================================
function OnRenderWindowClick()
{
  if (!g_pointerLocked)
  {
    g_canvas.requestPointerLock();
  }
}

//=========================================================================================
function PointerLockChangeCallback()
{
  if (document.pointerLockElement === g_canvas ||
    document.mozPointerLockElement === g_canvas ||
    document.webkitPointerLockElement === g_canvas) {
    // Pointer was just locked
    // Enable the mousemove listener
    document.addEventListener("mousemove", MouseMoveCallback, false);
    g_pointerLocked = true;
  } else {
    // Pointer was just unlocked
    // Disable the mousemove listener
    document.removeEventListener("mousemove", MouseMoveCallback, false);
    g_pointerLocked = false;
  }
}

//=========================================================================================
function MouseMoveCallback(e)
{
  var movementX = e.movementX ||
      e.mozMovementX          ||
      e.webkitMovementX       ||
      0;
  var movementY = e.movementY ||
      e.mozMovementY      ||
      e.webkitMovementY   ||
      0;

  g_cameraYawPitchRoll[0] -= g_cameraRotateSpeed * movementX;
  g_cameraYawPitchRoll[1] -= g_cameraRotateSpeed * movementY;

  // limit pitch to keep from flipping over
  if (g_cameraYawPitchRoll[1] < -Math.PI/2)
    g_cameraYawPitchRoll[1] = -Math.PI/2;
  else if (g_cameraYawPitchRoll[1] > Math.PI/2)
    g_cameraYawPitchRoll[1] = Math.PI/2;

  UpdateCameraMatrix();
}

//=========================================================================================
function CalculateNormals (pos)
{
  var normals = [];

  // for each triangle
  for (var index = 0; index < pos.length; index += 9)
  {
    var point0 = pos.slice(index, index + 3); 
    var point1 = pos.slice(index+3, index + 6); 
    var point2 = pos.slice(index+6, index + 9); 

    var edge1 = VectorSubtract(point1, point0);
    var edge2 = VectorSubtract(point2, point1);

    var normal = NormalizeVector(VectorCrossProduct(edge2, edge1));

    normals = normals.concat(normal);
    normals = normals.concat(normal);
    normals = normals.concat(normal);
  }

  return normals;
}

// TODO: could we calculate normals and tangents at the same time? what about sphere that doesn't want calculated normals? Maybe it ignores that part?
// TODO: Note the difference in calculating edge2 below vs above.  Maybe convert above to look like below first and then merge functions?
// TODO: does a sphere want smoothed tangents? not sure if it will make a difference or not.  I think it will, when looking at the tangent output.

//=========================================================================================
function CalculateTangents (pos, uv)
{
  var tangents = [];

  // for each triangle
  var uvIndex = 0;
  for (var index = 0; index < pos.length; index += 9)
  {
    var point0 = pos.slice(index, index + 3); 
    var point1 = pos.slice(index+3, index + 6); 
    var point2 = pos.slice(index+6, index + 9); 

    var uv0 = uv.slice(uvIndex, uvIndex + 2);
    var uv1 = uv.slice(uvIndex+2, uvIndex + 4);
    var uv2 = uv.slice(uvIndex+4, uvIndex + 6);

    var edge1 = VectorSubtract(point1, point0);
    var edge2 = VectorSubtract(point2, point0);

    var deltaUV1 = VectorSubtract(uv1, uv0);
    var deltaUV2 = VectorSubtract(uv2, uv0);

    var f = 1 / (deltaUV1[0] * deltaUV2[1] - deltaUV2[0] * deltaUV1[1]);

    var tangent = [];
    tangent[0] = f * (deltaUV2[1] * edge1[0] - deltaUV1[1] * edge2[0]);
    tangent[1] = f * (deltaUV2[1] * edge1[1] - deltaUV1[1] * edge2[1]);
    tangent[2] = f * (deltaUV2[1] * edge1[2] - deltaUV1[1] * edge2[2]);

    tangents = tangents.concat(tangent);
    tangents = tangents.concat(tangent);
    tangents = tangents.concat(tangent);

    uvIndex += 6;
  }

  return tangents;
}


//=========================================================================================
function GenerateTetrahedronMesh ()
{
  var ret = {};

  var pos = [];
  var uv = [];

  var point0 = [-1, 0, -1 / Math.sqrt(2)];
  var point1 = [ 1, 0, -1 / Math.sqrt(2)];
  var point2 = [ 0,-1,  1 / Math.sqrt(2)];
  var point3 = [ 0, 1,  1 / Math.sqrt(2)];

  pos = pos.concat(point2);
  pos = pos.concat(point1);
  pos = pos.concat(point0);

  pos = pos.concat(point0);
  pos = pos.concat(point1);
  pos = pos.concat(point3);  

  pos = pos.concat(point3);
  pos = pos.concat(point2);
  pos = pos.concat(point0);

  pos = pos.concat(point1);
  pos = pos.concat(point2);
  pos = pos.concat(point3);    

  uv = uv.concat([0, 0]);
  uv = uv.concat([0.5, 1]);
  uv = uv.concat([1, 0]);

  uv = uv.concat([0, 0]);
  uv = uv.concat([0.5, 1]);
  uv = uv.concat([1, 0]);

  uv = uv.concat([0, 0]);
  uv = uv.concat([0.5, 1]);
  uv = uv.concat([1, 0]);

  uv = uv.concat([0, 0]);
  uv = uv.concat([0.5, 1]);
  uv = uv.concat([1, 0]);  

  // make the normals and tangents
  var norm = CalculateNormals(pos);  
  var tangent = CalculateTangents(pos, uv);

  // make barycentric coordinates
  var barycentric = [];
  for (var i = 0; i < pos.length; i += 9)
  {
    barycentric = barycentric.concat([1,0,0]);
    barycentric = barycentric.concat([0,1,0]);
    barycentric = barycentric.concat([0,0,1]);   
  }

  ret.pos = pos;
  ret.norm = norm;
  ret.uv = uv;
  ret.barycentric = barycentric;
  ret.tangent = tangent;

  return ret;    
}

//=========================================================================================
function GenerateCubeMesh ()
{
  var ret = {};

  var pos = [];
  var uv = [];

  // front face
  {
    pos = pos.concat([-1,-1, 1]);
    pos = pos.concat([-1, 1, 1]);
    pos = pos.concat([ 1,-1, 1]);

    pos = pos.concat([-1, 1, 1]);
    pos = pos.concat([ 1, 1, 1]);
    pos = pos.concat([ 1,-1, 1]);

    uv = uv.concat([0, 0]);
    uv = uv.concat([0, 1]);
    uv = uv.concat([1, 0]);

    uv = uv.concat([0, 1]);
    uv = uv.concat([1, 1]);
    uv = uv.concat([1, 0]);       
  }

  // back face
  {
    pos = pos.concat([ 1,-1, -1]);
    pos = pos.concat([-1, 1, -1]);
    pos = pos.concat([-1,-1, -1]);

    pos = pos.concat([ 1,-1, -1]);
    pos = pos.concat([ 1, 1, -1]);
    pos = pos.concat([-1, 1, -1]);    

    uv = uv.concat([1, 0]);
    uv = uv.concat([0, 1]);
    uv = uv.concat([0, 0]);

    uv = uv.concat([1, 0]);
    uv = uv.concat([1, 1]);
    uv = uv.concat([0, 1]);      
  }

  // left face
  {
    pos = pos.concat([-1,-1,-1]);
    pos = pos.concat([-1, 1,-1]);
    pos = pos.concat([-1,-1, 1]);

    pos = pos.concat([-1, 1,-1]);
    pos = pos.concat([-1, 1, 1]);
    pos = pos.concat([-1,-1, 1]);

    uv = uv.concat([0, 0]);
    uv = uv.concat([0, 1]);
    uv = uv.concat([1, 0]);

    uv = uv.concat([0, 1]);
    uv = uv.concat([1, 1]);
    uv = uv.concat([1, 0]);       
  }

  // right face
  {
    pos = pos.concat([ 1,-1, 1]);
    pos = pos.concat([ 1, 1,-1]);
    pos = pos.concat([ 1,-1,-1]);
    
    pos = pos.concat([ 1,-1, 1]);
    pos = pos.concat([ 1, 1, 1]);
    pos = pos.concat([ 1, 1,-1]);

    uv = uv.concat([1, 0]);
    uv = uv.concat([0, 1]);
    uv = uv.concat([0, 0]);
    
    uv = uv.concat([1, 0]);    
    uv = uv.concat([1, 1]);
    uv = uv.concat([0, 1]);    
  }  

  // top face
  {
    pos = pos.concat([-1,-1,-1]);
    pos = pos.concat([-1,-1, 1]);
    pos = pos.concat([ 1,-1,-1]);

    pos = pos.concat([-1,-1, 1]);
    pos = pos.concat([ 1,-1, 1]);
    pos = pos.concat([ 1,-1,-1]);

    uv = uv.concat([0, 0]);
    uv = uv.concat([0, 1]);
    uv = uv.concat([1, 0]);

    uv = uv.concat([0, 1]);
    uv = uv.concat([1, 1]);
    uv = uv.concat([1, 0]);       
  }  

  // bottom face
  {
    pos = pos.concat([ 1, 1,-1]);
    pos = pos.concat([-1, 1, 1]);
    pos = pos.concat([-1, 1,-1]);

    pos = pos.concat([ 1, 1,-1]);
    pos = pos.concat([ 1, 1, 1]);
    pos = pos.concat([-1, 1, 1]);

    uv = uv.concat([1, 0]);
    uv = uv.concat([0, 1]);
    uv = uv.concat([0, 0]);

    uv = uv.concat([1, 0]);
    uv = uv.concat([1, 1]);
    uv = uv.concat([0, 1]);    
  }    

  // make the normals and tangents
  var norm = CalculateNormals(pos);  
  var tangent = CalculateTangents(pos, uv);

  // make barycentric coordinates
  var barycentric = [];
  for (var i = 0; i < pos.length; i += 9)
  {
    barycentric = barycentric.concat([1,0,0]);
    barycentric = barycentric.concat([0,1,0]);
    barycentric = barycentric.concat([0,0,1]);   
  }  

  ret.pos = pos;
  ret.norm = norm;
  ret.uv = uv;
  ret.barycentric = barycentric;
  ret.tangent = tangent;

  return ret;  
}

//=========================================================================================
function GenerateSphereMesh (slicesX, slicesY)
{
  var ret = {};

  var pos = [];
  var uv = [];

  // make the body of the sphere
  for (var indexY = 1; indexY < slicesY - 1; ++indexY)
  {
    var percentY1 = (indexY / slicesY);
    var percentY2 = ((indexY+1) / slicesY);
    for (var indexX = 0; indexX < slicesX; ++indexX)
    {
      var percentX1 = (indexX / slicesX);
      var percentX2 = ((indexX+1) / slicesX);
      var point00 = [Math.cos(percentX1*2*Math.PI) * Math.sin(percentY1*Math.PI), Math.cos(percentY1*Math.PI), Math.sin(percentX1*2*Math.PI) * Math.sin(percentY1*Math.PI)];
      var point10 = [Math.cos(percentX2*2*Math.PI) * Math.sin(percentY1*Math.PI), Math.cos(percentY1*Math.PI), Math.sin(percentX2*2*Math.PI) * Math.sin(percentY1*Math.PI)];
      var point01 = [Math.cos(percentX1*2*Math.PI) * Math.sin(percentY2*Math.PI), Math.cos(percentY2*Math.PI), Math.sin(percentX1*2*Math.PI) * Math.sin(percentY2*Math.PI)];
      var point11 = [Math.cos(percentX2*2*Math.PI) * Math.sin(percentY2*Math.PI), Math.cos(percentY2*Math.PI), Math.sin(percentX2*2*Math.PI) * Math.sin(percentY2*Math.PI)];

      var uv00 = [percentX1, percentY1];
      var uv10 = [percentX2, percentY1];
      var uv01 = [percentX1, percentY2];
      var uv11 = [percentX2, percentY2];

      // triangle 1 = 00, 01, 10
      pos = pos.concat(point00);
      pos = pos.concat(point01);
      pos = pos.concat(point10);

      uv = uv.concat(uv00);
      uv = uv.concat(uv01);
      uv = uv.concat(uv10);

      // triangle 2 = 01, 11, 10
      pos = pos.concat(point01);
      pos = pos.concat(point11);
      pos = pos.concat(point10);

      uv = uv.concat(uv01);
      uv = uv.concat(uv11);
      uv = uv.concat(uv10);     
    }
  }

  // make the caps of the sphere
  for (var indexX = 0; indexX < slicesX; ++indexX)
  {
      var percentX1 = (indexX / slicesX);
      var percentX2 = ((indexX+1) / slicesX);

      var percentY = (1 / slicesY);

      var point0 = [0, 1, 0];
      var point1 = [Math.cos(percentX1*2*Math.PI) * Math.sin(percentY*Math.PI), Math.cos(percentY*Math.PI), Math.sin(percentX1*2*Math.PI) * Math.sin(percentY*Math.PI)];
      var point2 = [Math.cos(percentX2*2*Math.PI) * Math.sin(percentY*Math.PI), Math.cos(percentY*Math.PI), Math.sin(percentX2*2*Math.PI) * Math.sin(percentY*Math.PI)];

      var uv0 = [0, 0];
      var uv1 = [percentX1, percentY];
      var uv2 = [percentX2, percentY];

      pos = pos.concat(point0);
      pos = pos.concat(point1);
      pos = pos.concat(point2);

      uv = uv.concat(uv0);
      uv = uv.concat(uv1);
      uv = uv.concat(uv2);      

      percentY = 1.0 - percentY;

      point2 = [0, -1, 0];
      point1 = [Math.cos(percentX1*2*Math.PI) * Math.sin(percentY*Math.PI), Math.cos(percentY*Math.PI), Math.sin(percentX1*2*Math.PI) * Math.sin(percentY*Math.PI)];
      point0 = [Math.cos(percentX2*2*Math.PI) * Math.sin(percentY*Math.PI), Math.cos(percentY*Math.PI), Math.sin(percentX2*2*Math.PI) * Math.sin(percentY*Math.PI)];

      var uv2 = [0, 1];
      var uv1 = [percentX1, percentY];
      var uv0 = [percentX2, percentY];      

      pos = pos.concat(point0);
      pos = pos.concat(point1);
      pos = pos.concat(point2);

      uv = uv.concat(uv0);
      uv = uv.concat(uv1);
      uv = uv.concat(uv2);      
  }

  // make the normals. We want smoothed normals on the sphere
  var norm = pos;

  // make the tangents
  var tangent = CalculateTangents(pos, uv);

  // make barycentric coordinates
  var barycentric = [];
  for (var i = 0; i < pos.length; i += 9)
  {
    barycentric = barycentric.concat([1,0,0]);
    barycentric = barycentric.concat([0,1,0]);
    barycentric = barycentric.concat([0,0,1]);   
  }  

  ret.pos = pos;
  ret.norm = norm;
  ret.uv = uv;
  ret.barycentric = barycentric;
  ret.tangent = tangent;

  return ret;
}

//=========================================================================================
function loadImage(url, callback) {
  var image = new Image();
  image.src = url;
  image.onload = callback;
  return image;
}

//=========================================================================================
function LoadImagesAndRender ()
{
  var imagesToLoad = g_imagesToLoad.length;
  var images = [];

  // Called each time an image finished loading.
  var onImageLoad = function() {
    --imagesToLoad;
    // If all the images are loaded call the callback.
    if (imagesToLoad == 0) {
      for (var i = 0; i < images.length; ++i)
      {
        var texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);

        gl.texImage2D(gl.TEXTURE_2D,
                      0,
                      gl.RGBA,
                      gl.RGBA,
                      gl.UNSIGNED_BYTE,
                      images[i]);           

        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);                           

        gl.generateMipmap(gl.TEXTURE_2D);
        g_images[g_imagesToLoad[i]] = texture;
      }

      gl.bindTexture(gl.TEXTURE_2D, null);

      DrawScene();
    }
  };
 
  for (var i = 0; i < g_imagesToLoad.length; ++i) {
    var image = loadImage(g_imagesToLoad[i], onImageLoad);
    images.push(image);
  }  
}

//=========================================================================================
function MakeMeshBuffers (mesh, program)
{
    // normals
    var normalAttributeLocation = gl.getAttribLocation(program, "a_normal");
    var normalBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
    gl.enableVertexAttribArray(normalAttributeLocation);
    gl.vertexAttribPointer(normalAttributeLocation, 3, gl.FLOAT, false, 0, 0);   
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(mesh.norm), gl.STATIC_DRAW);     

    // tangents
    var tangentAttributeLocation = gl.getAttribLocation(program, "a_tangent");
    var tangentBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, tangentBuffer);
    gl.enableVertexAttribArray(tangentAttributeLocation);
    gl.vertexAttribPointer(tangentAttributeLocation, 3, gl.FLOAT, false, 0, 0);   
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(mesh.tangent), gl.STATIC_DRAW);         

    // positions
    var positionAttributeLocation = gl.getAttribLocation(program, "a_position");
    var positionBuffer = gl.createBuffer(); 
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.enableVertexAttribArray(positionAttributeLocation);      
    gl.vertexAttribPointer(positionAttributeLocation, 3, gl.FLOAT, false, 0, 0);        
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(mesh.pos), gl.STATIC_DRAW);

    // uv
    var uvAttributeLocation = gl.getAttribLocation(program, "a_uv");
    var uvBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, uvBuffer);
    gl.enableVertexAttribArray(uvAttributeLocation);
    gl.vertexAttribPointer(uvAttributeLocation, 2, gl.FLOAT, false, 0, 0);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(mesh.uv), gl.STATIC_DRAW);

    // barycentric coordinates
    var barycentricAttributeLocation = gl.getAttribLocation(program, "a_barycentric");
    var barycentricBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, barycentricBuffer);
    gl.enableVertexAttribArray(barycentricAttributeLocation);
    gl.vertexAttribPointer(barycentricAttributeLocation, 3, gl.FLOAT, false, 0, 0);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(mesh.barycentric), gl.STATIC_DRAW);       
}

//=========================================================================================
function Initialize ()
{
    //debug panel starts closed
    ToggleDebugPanel();

    var havePointerLock = 'pointerLockElement' in document ||
        'mozPointerLockElement' in document ||
        'webkitPointerLockElement' in document;    

    // initialize webgl2
    g_canvas = document.getElementById("RenderWindow");
    gl = g_canvas.getContext("webgl2");
    if (!gl)
    {
        alert("could not get webgl2 context!");
        return;
    }

    // setup pointer lock to activate later
    if (!havePointerLock)
    {
      alert("your browser does not support pointer lock");
      return;
    }
    g_canvas.requestPointerLock = g_canvas.requestPointerLock ||
               g_canvas.mozRequestPointerLock ||
               g_canvas.webkitRequestPointerLock;     
    document.exitPointerLock = document.exitPointerLock ||
         document.mozExitPointerLock ||
         document.webkitExitPointerLock;
    document.addEventListener('pointerlockchange', PointerLockChangeCallback, false);
    document.addEventListener('mozpointerlockchange', PointerLockChangeCallback, false);
    document.addEventListener('webkitpointerlockchange', PointerLockChangeCallback, false);

    // make the meshes
    var sphereMesh = GenerateSphereMesh(20, 20);    
    var cubeMesh = GenerateCubeMesh();
    var tetrahedronMesh = GenerateTetrahedronMesh();

    // make the uniform definitions for the shaders
    g_uniformsShaderSource = "// uniform constants\n";
    for (var key in g_uniforms)
      g_uniformsShaderSource += "uniform " + g_uniforms[key][0] + " " + key + ";\n";    

    // make each shader permutation
    for (var i = 0; i < GetNumShaderPermutations(); ++i)
    {
      // make permutation specific defines
      var permutationSource = GetShaderPermutationSourceString(i);

      // make the shader
      var shader = MakeShader(vertexShaderSource, fragmentShaderSource, permutationSource);

      // make the sphere mesh buffers
      shader.sphereMeshVertCount = sphereMesh.pos.length;
      shader.sphereMesh = gl.createVertexArray();
      gl.bindVertexArray(shader.sphereMesh);    
      MakeMeshBuffers(sphereMesh, shader.program);

      // make the cube mesh buffers
      shader.cubeMeshVertCount = cubeMesh.pos.length;
      shader.cubeMesh = gl.createVertexArray();
      gl.bindVertexArray(shader.cubeMesh);    
      MakeMeshBuffers(cubeMesh, shader.program);     

      // make the tetrahedron mesh buffers
      shader.tetrahedronMeshVertCount = tetrahedronMesh.pos.length;
      shader.tetrahedronMesh = gl.createVertexArray();
      gl.bindVertexArray(shader.tetrahedronMesh);    
      MakeMeshBuffers(tetrahedronMesh, shader.program);           

      g_shaders[i] = shader;
    }

    // calculate initial camera matrix
    UpdateCameraMatrix();

    // load the images and then start rendering
    LoadImagesAndRender();
}

</script>
</head>
<body onLoad="Initialize();" onkeydown="return OnKeyDown(event);" onkeyup="return OnKeyUp(event);">
<div id="WholeWindow">
    <canvas id="RenderWindow" onclick="OnRenderWindowClick()"></canvas>
    <!--span id="LogDisplay"></span-->
    <span id="FPSDisplay">(?x?) FPS: ---</span>    
    <span id="CameraPosDisplay">Camera: (0.00,0.00,0.00)</span>    
    <span id="DebugPanel">
        <a href="#" id="DebugPanelCollapseIcon" onClick="ToggleDebugPanel(); return false;">[-] Debug Panel</a>
        <span id="DebugPanelControls">
            <hr>
            <table>
            <tr><td><input type="checkbox" id="Debug_Wireframe"/></td><td>Wireframe</td></tr>
            <tr><td><input type="checkbox" id="Debug_DrawPointLights"/></td><td>Draw Point Lights</td></tr>
            <tr><td><input type="checkbox" id="Debug_UseColoredLights"/></td><td>Colored Lights</td></tr>
            <tr><td><input type="checkbox" id="Debug_AnimateLights"/></td><td>Animate Lights</td></tr>
            <tr><td><input type="checkbox" id="Debug_PointLight0" checked="true"/></td><td>Point Light 0</td></tr>
            <tr><td><input type="checkbox" id="Debug_PointLight1" checked="true"/></td><td>Point Light 1</td></tr>
            <tr><td><input type="checkbox" id="Debug_PointLight2" checked="true"/></td><td>Point Light 2</td></tr>
            <tr><td><input type="checkbox" id="Debug_PointLight3" checked="true"/></td><td>Point Light 3</td></tr>
            <tr><td><input type="checkbox" id="Debug_AnimateObjects"/></td><td>Animate Objects</td></tr>
            </table>
            <table>            
            <tr><td>Draw</td><td>
            <select id="Debug_SceneSingle">
              <option value="0">PBR Grid of</option>
              <option value="1">Grid of</option>
              <option value="2">Cube of</option>
              <option value="3" selected="true">Single</option>
            </select>
            <select id="Debug_SceneMaterial">
              <option value="0">Untextured</option>
              <option value="1" selected="true">Rusty Iron</option>
              <option value="2">Rough Rock</option>
              <option value="3">Greasy Pan</option>
              <option value="4">Scuffed Iron</option>
              <option value="5">Sculpted Floorboards</option>
            </select>           
            <select id="Debug_SceneObject">
              <option value="0">Sphere</option>
              <option value="1">Cube</option>
              <option value="2">Tetrahedron</option>
            </select>                 
            </td></tr>         
            <tr><td>Metallic</td><td><input id="Debug_Metallic" type="range" min="0" max="2" value="1.0" step="0.01"/> <input type="button" onClick="document.getElementById('Debug_Metallic').value=1.0;" value="Reset"/></td></tr>
            <tr><td>Roughness</td><td><input id="Debug_Roughness" type="range" min="0" max="2" value="1.0" step="0.01"/> <input type="button" onClick="document.getElementById('Debug_Roughness').value=1.0;" value="Reset"/></td></tr>
            <tr><td>Albedo R</td><td><input id="Debug_AlbedoR" type="range" min="0" max="1" value="1.0" step="0.01"/></td></tr>
            <tr><td>Albedo G</td><td><input id="Debug_AlbedoG" type="range" min="0" max="1" value="1.0" step="0.01"/></td></tr>
            <tr><td>Albedo B</td><td><input id="Debug_AlbedoB" type="range" min="0" max="1" value="1.0" step="0.01"/></td></tr>
            <tr><td>Output</td><td>
            <select id="Debug_OutputMode">
              <option value="0">Shaded</option>
              <option value="1">Albedo</option>
              <option value="2">Normal</option>    
              <option value="3">Metallic</option>
              <option value="4">Roughness</option>
              <option value="5">Emissive</option>
              <option value="6">AO</option>
            </select>
            </td></tr>
            </table>
        </span>
    </span>
</div>
</body>

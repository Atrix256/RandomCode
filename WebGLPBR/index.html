<html>
<head>
<title>WebGL</title>
<style type="text/css">
body { border-collapse: collapse; margin:0; padding:0;}
canvas#RenderWindow {position: absolute; left: 0; top: 0; z-index: 0; width:100%; height:100%;}
span#DebugPanel {position: absolute; right: 0; top: 0; z-index: 1; color: #00FF00; background-color: rgba(255,255,255,0.3); padding: 10px;}
span#FPSDisplay {position: absolute; left: 0; bottom: 0; z-index: 1; color: #00FF00; background-color: rgba(255,255,255,0.0); padding: 10px;}
div#WholeWindow {position:relative; width:100%; height:100%;}
a#DebugPanelCollapseIcon {color:#00FF00;text-decoration: none; font-weight: bold; text-align: right; display: block;}
}
</style>
<script>
/*=========================================================================================
Created by Alan Wolfe
http://demofox.org
http://blog.demofox.org
https://twitter.com/Atrix256

=========================================================================================*/

var g_canvas = null;
var gl = null;
var g_debugPanelOpen = true;

var g_projectionMatrix;
var g_cameraMatrix;

var g_cameraPosition = [0,0,0];

var g_cameraYawPitch = [0, 0];

var g_cameraMoveSpeed = 2.0;    // meters per second
var g_cameraRotateSpeed = 0.01; // radians per second


var g_lastFrameTimeStamp = 0;
var g_frameCount = 0;
var g_frameCountTime = 0;

var g_keyState = new Array();

var g_pointerLocked = false;


var g_shader = null;

var g_vao = null;
var g_vaoVertCount = 0;

// You can use these uniforms in your vertex or pixel shaders without defining them, they are automatically piped through if used.
// If editing these, also need to edit FillUniformValue()
var g_uniforms = {
  "u_projectionMatrix" : "mat4",
  "u_cameraMatrix" : "mat4",
  "u_objectMatrix" : "mat4",
  "u_screenResolution" : "vec2",
};

var g_uniformsShaderSource = "";

//=========================================================================================
var precisionSource = "precision mediump float;\n\n";

//=========================================================================================
var vertexShaderSource = ` 
// vertex input
in vec4 a_position;

// vertex output
out vec3 v_worldPos;

void main()
{
  v_worldPos = (u_objectMatrix * a_position).xyz;
  gl_Position = u_projectionMatrix * u_cameraMatrix * u_objectMatrix * a_position;
}
`;
 
 //=========================================================================================
var fragmentShaderSource = ` 
// pixel input
in vec3 v_worldPos;

// pixel output
out vec4 outColor;
 
void main()
{
  // position in screen space as a percentage
  //vec2 pos = gl_FragCoord.xy / u_screenResolution;

  // set the output color
  outColor = vec4(abs(v_worldPos.xyz), 1);
}
`;

//=========================================================================================
function CreateShader (gl, type, source) {
  var fullSource = "#version 300 es\n\n" + precisionSource + g_uniformsShaderSource + source;

  var shader = gl.createShader(type);
  gl.shaderSource(shader, fullSource);
  gl.compileShader(shader);
  var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
  if (success) {
    return shader;
  }

  var shaderErrorInfo = gl.getShaderInfoLog(shader);
  alert(shaderErrorInfo + "\n" + fullSource);

  console.log(shaderErrorInfo);
  console.log(fullSource);
  gl.deleteShader(shader);
}

//=========================================================================================
function CreateProgram (gl, vertexShader, fragmentShader) {
  var program = gl.createProgram();
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.linkProgram(program);
  var success = gl.getProgramParameter(program, gl.LINK_STATUS);
  if (success) {
    return program;
  }
 
  console.log(gl.getProgramInfoLog(program));
  gl.deleteProgram(program);
}

//=========================================================================================
function MakeShader (vertexSource, fragmentSource)
{
    // compile shader
    var vertexShader = CreateShader(gl, gl.VERTEX_SHADER, vertexSource);
    var fragmentShader = CreateShader(gl, gl.FRAGMENT_SHADER, fragmentSource);    
    var program = CreateProgram(gl, vertexShader, fragmentShader);

    // get the uniform locations, for any uniforms it may use
    var shader = {};
    shader.program = program;
    shader.uniforms = {};
    for (var key in g_uniforms)
      shader.uniforms[key] = gl.getUniformLocation(shader.program, key);

    // return the shader to the caller
    return shader;
}

//=========================================================================================
function UpdateCameraMatrix ()
{
    g_cameraMatrix = CameraMatrix(g_cameraYawPitch[0], g_cameraYawPitch[1], 0, g_cameraPosition[0], g_cameraPosition[1], g_cameraPosition[2]);
}

//=========================================================================================
function UpdateProjectionMatrix ()
{
    g_projectionMatrix = Perspective(45.0 * 3.14 / 180.0, gl.canvas.width / gl.canvas.height, 1.0, 2000.0);
}

//=========================================================================================
function Resize (canvas) {
  // Lookup the size the browser is displaying the canvas.
  var displayWidth  = canvas.clientWidth;
  var displayHeight = canvas.clientHeight;
 
  // Check if the canvas is not the same size.
  if (canvas.width  !== displayWidth ||
      canvas.height !== displayHeight) {
 
      // Make the canvas the same size
      canvas.width  = displayWidth;
      canvas.height = displayHeight;

      UpdateProjectionMatrix();
  }
}

//=========================================================================================
function Perspective (fieldOfViewInRadians, aspect, near, far) {
    var f = Math.tan(Math.PI * 0.5 - 0.5 * fieldOfViewInRadians);
    var rangeInv = 1.0 / (near - far);
 
    return [
      f / aspect, 0, 0, 0,
      0, f, 0, 0,
      0, 0, (near + far) * rangeInv, -1,
      0, 0, near * far * rangeInv * 2, 0
    ];
}

//=========================================================================================
function MultiplyMatrix4x4 (A, B)
{
  var ret = [];

  for (var i = 0; i < 4; ++i)
  {
    for (var j = 0; j < 4; ++j)
    {
      ret[i*4+j] = 
        A[i*4+0] * B[0*4+j] + 
        A[i*4+1] * B[1*4+j] + 
        A[i*4+2] * B[2*4+j] + 
        A[i*4+3] * B[3*4+j];
    }
  }

  return ret;
}

//=========================================================================================
function CameraMatrix (yaw, pitch, roll, positionX, positionY, positionZ) {

  var cosAlpha = Math.cos(roll);
  var sinAlpha = Math.sin(roll);

  var cosBeta = Math.cos(yaw);
  var sinBeta = Math.sin(yaw);

  var cosGamma = Math.cos(pitch);
  var sinGamma = Math.sin(pitch);

  var rot = [
    cosAlpha * cosBeta, cosAlpha * sinBeta * sinGamma - sinAlpha * cosGamma, cosAlpha * sinBeta * cosGamma + sinAlpha * sinGamma, 0,
    sinAlpha * cosBeta, sinAlpha * sinBeta * sinGamma + cosAlpha * cosGamma, sinAlpha * sinBeta * cosGamma - cosAlpha * sinGamma, 0,
    -sinBeta, cosBeta * sinGamma, cosBeta * cosGamma, 0,
    0, 0, 0, 1
  ];

  var trans = [
    1, 0, 0, 0,
    0, 1, 0, 0,
    0, 0, 1, 0,
    positionX, positionY, positionZ, 1
  ];

  return MultiplyMatrix4x4(trans, rot);
}

//=========================================================================================
function NormalizeVector (v)
{
  var length = Math.sqrt(v[0]*v[0]+v[1]*v[1]+v[2]*v[2]);
  return [v[0]/length, v[1]/length, v[2]/length];
}

//=========================================================================================
function CameraForward ()
{
  return [g_cameraMatrix[0*4+2], g_cameraMatrix[1*4+2], g_cameraMatrix[2*4+2]];
}

//=========================================================================================
function CameraRight ()
{
  return [g_cameraMatrix[0*4+0], g_cameraMatrix[1*4+0], g_cameraMatrix[2*4+0]];
}

//=========================================================================================
function GetObjectValue (objectValues, key)
{
  if (objectValues[key] == null)
    throw new Error("Missing object value asked for in GetObjectValue() : " + key);

  return objectValues[key];
}

//=========================================================================================
function FillUniformValue (key, location, objectValues)
{
  // if the shader doesn't use this uniform, nothing to fill in
  if (location == null)
    return;

  // fill in whatever uniform was asked for
  switch(key)
  {
    case "u_projectionMatrix": gl.uniformMatrix4fv(location, false, g_projectionMatrix); break;
    case "u_cameraMatrix": gl.uniformMatrix4fv(location, false, g_cameraMatrix); break;
    case "u_objectMatrix": gl.uniformMatrix4fv(location, false, objectValues.u_objectMatrix); break;
    case "u_screenResolution": gl.uniform2fv(location, [gl.canvas.width, gl.canvas.height]); break;
    default: throw new Error("Unknown uniform asked for in FillUniformValue()");
  }
}

//=========================================================================================
function DrawSphere (offsetX, offsetY, offsetZ, scaleX, scaleY, scaleZ)
{
    // Tell it to use our program (pair of shaders)
    gl.useProgram(g_shader.program);    

    // make our object values
    // u_objectMatrix
    var objectValues = {};
    objectValues.u_objectMatrix = [
      scaleX, 0, 0, 0,
      0, scaleY, 0, 0,
      0, 0, scaleZ, 0,
      offsetX, offsetY, offsetZ, 1
    ];

    // fill out the uniforms
    for (var key in g_shader.uniforms)
        FillUniformValue(key, g_shader.uniforms[key], objectValues);

    // Bind the attribute/buffer set we want.
    gl.bindVertexArray(g_vao);    

    var primitiveType = document.getElementById("Debug_Wireframe").checked ? gl.LINE_STRIP : gl.TRIANGLES;
    var offset = 0;
    var count = g_vaoVertCount / 3;
    gl.drawArrays(primitiveType, offset, count);      
}

//=========================================================================================
function DrawScene (thisFrameTimeStamp)
{
    // calculate a delta time for our frame
    var deltaTime = 0.0;
    if (typeof thisFrameTimeStamp != 'undefined')
    {
      thisFrameTimeStamp *= 0.001;
      deltaTime = thisFrameTimeStamp - g_lastFrameTimeStamp;
      g_lastFrameTimeStamp = thisFrameTimeStamp;
    }

    // handle FPS calculation
    g_frameCount++;
    g_frameCountTime+=deltaTime;
    if (g_frameCountTime > 0.5)
    {
      var fps = g_frameCount / g_frameCountTime;
      document.getElementById("FPSDisplay").innerText = "FPS: " + fps.toFixed(2);
      g_frameCount = 0;
      g_frameCountTime = 0;
    }

    // TODO: temp! Move this to a different function or something.
    // W or up arrowd
    var movement = g_cameraMoveSpeed * deltaTime;
    if (g_keyState[87] || g_keyState[38])
    {
      var vec = CameraForward();
      g_cameraPosition[0] += vec[0] * movement;
      g_cameraPosition[1] += vec[1] * movement;
      g_cameraPosition[2] += vec[2] * movement;
      UpdateCameraMatrix();
    }
    // S or down arrow
    if (g_keyState[83] || g_keyState[40])
    {
      var vec = CameraForward();
      g_cameraPosition[0] -= vec[0] * movement;
      g_cameraPosition[1] -= vec[1] * movement;
      g_cameraPosition[2] -= vec[2] * movement;      
      UpdateCameraMatrix();
    }
    // A or left arrow
    if (g_keyState[65] || g_keyState[37])
    {
      var vec = CameraRight();
      g_cameraPosition[0] += vec[0] * movement;
      g_cameraPosition[1] += vec[1] * movement;
      g_cameraPosition[2] += vec[2] * movement;          
      UpdateCameraMatrix();
    }    
    // D or right arrow
    if (g_keyState[68] || g_keyState[39])
    {
      var vec = CameraRight();
      g_cameraPosition[0] -= vec[0] * movement;
      g_cameraPosition[1] -= vec[1] * movement;
      g_cameraPosition[2] -= vec[2] * movement;          
      UpdateCameraMatrix();
    }       

    // Draw
    Resize(gl.canvas);
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

    // enable depth test
    gl.enable(gl.DEPTH_TEST);
    gl.depthFunc(gl.LESS);

    // Clear the canvas
    gl.clearColor(0, 0, 0, 255);
    gl.clear(gl.COLOR_BUFFER_BIT);    

    // draw some spheres
    DrawSphere(0, 0, -5, 0.25, 0.25, 0.25);
    DrawSphere(0, 0, -10, 1, 1, 1);

    // request another frame to be drawn
    requestAnimationFrame(DrawScene);
}

//=========================================================================================
function ToggleDebugPanel ()
{
    g_debugPanelOpen = !g_debugPanelOpen;

    if (g_debugPanelOpen)
    {
        document.getElementById("DebugPanelControls").style.visibility = "visible";
        document.getElementById("DebugPanelControls").style.display = "";        
        document.getElementById("DebugPanelCollapseIcon").innerText="[-] Debug Panel";
    }
    else
    {
        document.getElementById("DebugPanelControls").style.visibility = "hidden";
        document.getElementById("DebugPanelControls").style.display = "none";        
        document.getElementById("DebugPanelCollapseIcon").innerText="[+] Debug Panel";
    }
}

//=========================================================================================
function OnKeyDown(event)
{
  g_keyState[event.keyCode] = true;
}

//=========================================================================================
function OnKeyUp(event)
{
  g_keyState[event.keyCode] = false;
}

//=========================================================================================
function OnRenderWindowClick()
{
  if (!g_pointerLocked)
  {
    g_canvas.requestPointerLock();
  }
}

//=========================================================================================
function PointerLockChangeCallback()
{
  if (document.pointerLockElement === g_canvas ||
    document.mozPointerLockElement === g_canvas ||
    document.webkitPointerLockElement === g_canvas) {
    // Pointer was just locked
    // Enable the mousemove listener
    document.addEventListener("mousemove", MouseMoveCallback, false);
    g_pointerLocked = true;
  } else {
    // Pointer was just unlocked
    // Disable the mousemove listener
    document.removeEventListener("mousemove", MouseMoveCallback, false);
    g_pointerLocked = false;
  }
}

//=========================================================================================
function MouseMoveCallback(e)
{
  var movementX = e.movementX ||
      e.mozMovementX          ||
      e.webkitMovementX       ||
      0;
  var movementY = e.movementY ||
      e.mozMovementY      ||
      e.webkitMovementY   ||
      0;

  g_cameraYawPitch[0] -= g_cameraRotateSpeed * movementX;
  g_cameraYawPitch[1] -= g_cameraRotateSpeed * movementY;

  UpdateCameraMatrix();
}

//=========================================================================================
function GenerateSphereMesh (slicesX, slicesY)
{
  var ret = [];

  // make the body of the sphere
  for (var indexY = 1; indexY < slicesY - 1; ++indexY)
  {
    var percentY1 = (indexY / slicesY);
    var percentY2 = ((indexY+1) / slicesY);
    for (var indexX = 0; indexX < slicesX; ++indexX)
    {
      var percentX1 = (indexX / slicesX);
      var percentX2 = ((indexX+1) / slicesX);
      var point00 = [Math.cos(percentX1*2*Math.PI) * Math.sin(percentY1*Math.PI), Math.cos(percentY1*Math.PI), Math.sin(percentX1*2*Math.PI) * Math.sin(percentY1*Math.PI)];
      var point10 = [Math.cos(percentX2*2*Math.PI) * Math.sin(percentY1*Math.PI), Math.cos(percentY1*Math.PI), Math.sin(percentX2*2*Math.PI) * Math.sin(percentY1*Math.PI)];
      var point01 = [Math.cos(percentX1*2*Math.PI) * Math.sin(percentY2*Math.PI), Math.cos(percentY2*Math.PI), Math.sin(percentX1*2*Math.PI) * Math.sin(percentY2*Math.PI)];
      var point11 = [Math.cos(percentX2*2*Math.PI) * Math.sin(percentY2*Math.PI), Math.cos(percentY2*Math.PI), Math.sin(percentX2*2*Math.PI) * Math.sin(percentY2*Math.PI)];

      // triangle 1 = 00, 01, 10
      ret = ret.concat(point00);
      ret = ret.concat(point01);
      ret = ret.concat(point10);

      // triangle 2 = 01, 11, 10
      ret = ret.concat(point01);
      ret = ret.concat(point11);
      ret = ret.concat(point10);
    }
  }

  // make the caps of the sphere
  for (var indexX = 0; indexX < slicesX; ++indexX)
  {
      var percentX1 = (indexX / slicesX);
      var percentX2 = ((indexX+1) / slicesX);

      var percentY = (1 / slicesY);

      var point0 = [0, 1, 0];
      var point1 = [Math.cos(percentX1*2*Math.PI) * Math.sin(percentY*Math.PI), Math.cos(percentY*Math.PI), Math.sin(percentX1*2*Math.PI) * Math.sin(percentY*Math.PI)];
      var point2 = [Math.cos(percentX2*2*Math.PI) * Math.sin(percentY*Math.PI), Math.cos(percentY*Math.PI), Math.sin(percentX2*2*Math.PI) * Math.sin(percentY*Math.PI)];

      ret = ret.concat(point0);
      ret = ret.concat(point1);
      ret = ret.concat(point2);

      percentY = 1.0 - percentY;

      point0 = [0, -1, 0];
      point1 = [Math.cos(percentX1*2*Math.PI) * Math.sin(percentY*Math.PI), Math.cos(percentY*Math.PI), Math.sin(percentX1*2*Math.PI) * Math.sin(percentY*Math.PI)];
      point2 = [Math.cos(percentX2*2*Math.PI) * Math.sin(percentY*Math.PI), Math.cos(percentY*Math.PI), Math.sin(percentX2*2*Math.PI) * Math.sin(percentY*Math.PI)];

      ret = ret.concat(point0);
      ret = ret.concat(point1);
      ret = ret.concat(point2);
  }

  return ret;
}

//=========================================================================================
function Initialize ()
{
    //debug panel starts closed
    ToggleDebugPanel();

    var havePointerLock = 'pointerLockElement' in document ||
        'mozPointerLockElement' in document ||
        'webkitPointerLockElement' in document;    

    // initialize webgl2
    g_canvas = document.getElementById("RenderWindow");
    gl = g_canvas.getContext("webgl2");
    if (!gl)
    {
        alert("could not get webgl2 context!");
        return;
    }


    // setup pointer lock to activate later
    if (!havePointerLock)
    {
      alert("your browser does not support pointer lock");
      return;
    }
    g_canvas.requestPointerLock = g_canvas.requestPointerLock ||
               g_canvas.mozRequestPointerLock ||
               g_canvas.webkitRequestPointerLock;     
    document.exitPointerLock = document.exitPointerLock ||
         document.mozExitPointerLock ||
         document.webkitExitPointerLock;
    document.addEventListener('pointerlockchange', PointerLockChangeCallback, false);
    document.addEventListener('mozpointerlockchange', PointerLockChangeCallback, false);
    document.addEventListener('webkitpointerlockchange', PointerLockChangeCallback, false);

    // make the uniform definitions for the shaders
    g_uniformsShaderSource = "// uniform constants\n";
    for (var key in g_uniforms)
      g_uniformsShaderSource += "uniform " + g_uniforms[key] + " " + key + ";\n";    

    // make the shader
    g_shader = MakeShader(vertexShaderSource, fragmentShaderSource);


    var positionAttributeLocation = gl.getAttribLocation(g_shader.program, "a_position");

    var positionBuffer = gl.createBuffer();

    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

    var positions = GenerateSphereMesh(20, 20);

    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

    g_vaoVertCount = positions.length;
    g_vao = gl.createVertexArray();
    gl.bindVertexArray(g_vao);

    gl.enableVertexAttribArray(positionAttributeLocation);

    var size = 3;          // 3 components per iteration
    var type = gl.FLOAT;   // the data is 32bit floats
    var normalize = false; // don't normalize the data
    var stride = 0;        // 0 = move forward size * sizeof(type) each iteration to get the next position
    var offset = 0;        // start at the beginning of the buffer
    gl.vertexAttribPointer(
        positionAttributeLocation, size, type, normalize, stride, offset);


    // calculate initial camera matrix
    UpdateCameraMatrix();

    // Start rendering
    DrawScene();
}

</script>
</head>
<body onLoad="Initialize();" onkeydown="return OnKeyDown(event);" onkeyup="return OnKeyUp(event);">
<div id="WholeWindow">
    <canvas id="RenderWindow" onclick="OnRenderWindowClick()"></canvas>
    <span id="FPSDisplay">FPS: ---</span>    
    <span id="DebugPanel">
        <a href="#" id="DebugPanelCollapseIcon" onClick="ToggleDebugPanel(); return false;">[-] Debug Panel</a>
        <span id="DebugPanelControls">
            <hr>
            <input type="checkbox" id="Debug_Wireframe"/>Wireframe<br>
        </span>
    </span>
</div>
</body>
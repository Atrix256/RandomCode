<html>
<head>
<title>WebGL</title>
<style type="text/css">
body { border-collapse: collapse; margin:0; padding:0;}
canvas#RenderWindow {position: absolute; left: 0; top: 0; z-index: 0; width:100%; height:100%;}
span#DebugPanel {position: absolute; right: 0; top: 0; z-index: 1; color: #00FF00; background-color: rgba(255,255,255,0.3); padding: 10px;}
span#FPSDisplay {position: absolute; left: 0; bottom: 0; z-index: 1; color: #00FF00; background-color: rgba(255,255,255,0.0); padding: 10px;}
div#WholeWindow {position:relative; width:100%; height:100%;}
a#DebugPanelCollapseIcon {color:#00FF00;text-decoration: none; font-weight: bold; text-align: right; display: block;}
}
</style>
<script>
/*=========================================================================================
Created by Alan Wolfe
http://demofox.org
http://blog.demofox.org
https://twitter.com/Atrix256

=========================================================================================*/

var g_canvas = null;
var gl = null;
var g_debugPanelOpen = true;

var u_projectionMatrix = null;

var g_projectionMatrix;


var g_lastFrameTimeStamp = 0;
var g_frameCount = 0;
var g_frameCountTime = 0;


var g_program = null;
var g_vao = null;

//=========================================================================================
var vertexShaderSource = ` 
// an attribute is an input (in) to a vertex shader.
// It will receive data from a buffer
in vec4 a_position;

uniform mat4 u_projectionMatrix;
 
// all shaders have a main function
void main() {
 
  // gl_Position is a special variable a vertex shader
  // is responsible for setting
  gl_Position = u_projectionMatrix * a_position;
}
`;
 
 //=========================================================================================
var fragmentShaderSource = ` 
// fragment shaders don't have a default precision so we need
// to pick one. mediump is a good default. It means "medium precision"
precision mediump float;
 
// we need to declare an output for the fragment shader
out vec4 outColor;
 
void main() {
  // Just set the output to a constant redish-purple
  outColor = vec4(1, 0, 0.5, 1);
}
`;

//=========================================================================================
function CreateShader (gl, type, source) {
  var fullSource = "#version 300 es\n" + source;

  var shader = gl.createShader(type);
  gl.shaderSource(shader, fullSource);
  gl.compileShader(shader);
  var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
  if (success) {
    return shader;
  }

  var shaderErrorInfo = gl.getShaderInfoLog(shader);
  alert(shaderErrorInfo + "\n" + fullSource);

  console.log(shaderErrorInfo);
  console.log(fullSource);
  gl.deleteShader(shader);
}

//=========================================================================================
function CreateProgram (gl, vertexShader, fragmentShader) {
  var program = gl.createProgram();
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.linkProgram(program);
  var success = gl.getProgramParameter(program, gl.LINK_STATUS);
  if (success) {
    return program;
  }
 
  console.log(gl.getProgramInfoLog(program));
  gl.deleteProgram(program);
}

//=========================================================================================
function UpdateCamera () {
    g_projectionMatrix = Perspective(45.0 * 3.14 / 180.0, gl.canvas.width / gl.canvas.height, 1.0, 200.0);
}

//=========================================================================================
function Resize (canvas) {
  // Lookup the size the browser is displaying the canvas.
  var displayWidth  = canvas.clientWidth;
  var displayHeight = canvas.clientHeight;
 
  // Check if the canvas is not the same size.
  if (canvas.width  !== displayWidth ||
      canvas.height !== displayHeight) {
 
      // Make the canvas the same size
      canvas.width  = displayWidth;
      canvas.height = displayHeight;

      UpdateCamera();
  }
}

//=========================================================================================
function Perspective (fieldOfViewInRadians, aspect, near, far) {
    var f = Math.tan(Math.PI * 0.5 - 0.5 * fieldOfViewInRadians);
    var rangeInv = 1.0 / (near - far);
 
    return [
      f / aspect, 0, 0, 0,
      0, f, 0, 0,
      0, 0, (near + far) * rangeInv, -1,
      0, 0, near * far * rangeInv * 2, 0
    ];
}

//=========================================================================================
function DrawScene (thisFrameTimeStamp)
{
    // calculate a delta time for our frame
    var deltaTime = 0.0;
    if (typeof thisFrameTimeStamp != 'undefined')
    {
      thisFrameTimeStamp *= 0.001;
      deltaTime = thisFrameTimeStamp - g_lastFrameTimeStamp;
      g_lastFrameTimeStamp = thisFrameTimeStamp;
    }

    // handle FPS calculation
    g_frameCount++;
    g_frameCountTime+=deltaTime;
    if (g_frameCountTime > 0.5)
    {
      var fps = g_frameCount / g_frameCountTime;
      document.getElementById("FPSDisplay").innerText = "FPS: " + fps.toFixed(2);
      g_frameCount = 0;
      g_frameCountTime = 0;
    }


    Resize(gl.canvas);
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

    // Clear the canvas
    gl.clearColor(0, 0, 0, 255);
    gl.clear(gl.COLOR_BUFFER_BIT);    

    // Tell it to use our program (pair of shaders)
    gl.useProgram(g_program);    

    // send the projection matrix over
    gl.uniformMatrix4fv(u_projectionMatrix, false, g_projectionMatrix);    

    // Bind the attribute/buffer set we want.
    gl.bindVertexArray(g_vao);    

    var primitiveType = gl.TRIANGLES;
    var offset = 0;
    var count = 3;
    gl.drawArrays(primitiveType, offset, count);    

    // request another frame to be drawn
    requestAnimationFrame(DrawScene);
}

//=========================================================================================
function ToggleDebugPanel ()
{
    g_debugPanelOpen = !g_debugPanelOpen;

    if (g_debugPanelOpen)
    {
        document.getElementById("DebugPanelControls").style.visibility = "visible";
        document.getElementById("DebugPanelControls").style.display = "";        
        document.getElementById("DebugPanelCollapseIcon").innerText="[-] Debug Panel";
    }
    else
    {
        document.getElementById("DebugPanelControls").style.visibility = "hidden";
        document.getElementById("DebugPanelControls").style.display = "none";        
        document.getElementById("DebugPanelCollapseIcon").innerText="[+] Debug Panel";
    }
}

//=========================================================================================
function Initialize ()
{
    //debug panel starts closed
    ToggleDebugPanel();

    g_canvas = document.getElementById("RenderWindow");
    gl = g_canvas.getContext("webgl2");
    if (!gl)
    {
        alert("could not get webgl2 context!");
        return;
    }

    var vertexShader = CreateShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
    var fragmentShader = CreateShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);    
    g_program = CreateProgram(gl, vertexShader, fragmentShader);

    u_projectionMatrix = gl.getUniformLocation(g_program, "u_projectionMatrix");

    var positionAttributeLocation = gl.getAttribLocation(g_program, "a_position");

    var positionBuffer = gl.createBuffer();

    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

    // three 2d points
    var positions = [
        0, 0, -2,
        0, 1, -2,
        1, 0, -2
    ];
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

    g_vao = gl.createVertexArray();
    gl.bindVertexArray(g_vao);

    gl.enableVertexAttribArray(positionAttributeLocation);

    var size = 3;          // 2 components per iteration
    var type = gl.FLOAT;   // the data is 32bit floats
    var normalize = false; // don't normalize the data
    var stride = 0;        // 0 = move forward size * sizeof(type) each iteration to get the next position
    var offset = 0;        // start at the beginning of the buffer
    gl.vertexAttribPointer(
        positionAttributeLocation, size, type, normalize, stride, offset);


    DrawScene();
}

</script>
</head>
<body onLoad="Initialize();">
<div id="WholeWindow">
    <canvas id="RenderWindow"></canvas>
    <span id="FPSDisplay">FPS: ---</span>    
    <span id="DebugPanel">
        <a href="#" id="DebugPanelCollapseIcon" onClick="ToggleDebugPanel(); return false;">[-] Debug Panel</a>
        <span id="DebugPanelControls">
            <hr>
            <input type="checkbox" id="Wireframe"/>Wireframe<br>
            Camera Mode
            <select>
                <option value="Overhead">Overhead</option>
                <option value="FirstPerson">First Person</option>
                <option value="Free">Free</option>
            </select>
        </span>
    </span>
</div>
</body>